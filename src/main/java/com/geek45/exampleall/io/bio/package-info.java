/**
 *  客户端  ：  使用socket链接服务端，然后发送消息
 *  服务端  ：  使用socket等待连接，然后接受消息
 *
 *
 *  概念：
 *  Java BIO (blocking I/O)：
 *      同步并阻塞，服务器实现模式为一个连接一个线程，
 *      即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，
 *      当然可以通过线程池机制改善。
 *
 *      BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
 *
 *  单线程模式下：
 *      -->启动服务端
 *      -->服务端阻塞在serverSocket.accept();
 *      -->当有服务链接后，继续处理
 *      -->阻塞在socket.getInputStream().read(buffer);   此处如果客户端会立刻直接write，这里会立刻read到，然后处理完成
 *      -->继续回到serverSocket.accept();  进行阻塞。
 *  不足：
 *      如果一个用户链接上了，然后不进行write，服务端就会一直卡在read处，此时其他客户端就无法和服务端链接。
 *      即BIO的一大特性，在BIO内部，会进行两次阻塞，一次连接处，一次处理消息处。该特性导致单线程BIO无法处理多客户端请求。
 *  弥补，变成多线程：
 *      当有用户连接上之后，启动一个新的线程去处理read方法，这样主线程就又能回到serverSocket.accept();处进行等待下一个链接。
 *  弥补后的弱点：
 *      多线程下的BIO，每一个请求来了，不管是否发送消息，都会为连接创建一个线程。小了还好，当客户端连接数增多了之后，而且都是不活跃的连接，那么会极大的消耗服务器的资源。
 *
 */
package com.geek45.exampleall.io.bio;