/**
 *  客户端  ：  使用socket链接服务端，然后发送消息
 *  服务端  ：  使用socket等待连接，然后接受消息
 *
 *
 *  概念：
 *  Java BIO (blocking I/O)：
 *      同步并阻塞，服务器实现模式为一个连接一个线程，
 *      即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，
 *      当然可以通过线程池机制改善。
 *
 *      BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
 *
 *  单线程模式下：
 *      -->启动服务端
 *      -->服务端阻塞在serverSocket.accept();
 *      -->当有服务链接后，继续处理
 *      -->阻塞在socket.getInputStream().read(buffer);   此处如果客户端会立刻直接write，这里会立刻read到，然后处理完成
 *      -->继续回到serverSocket.accept();  进行阻塞。
 *  不足：
 *      如果一个用户链接上了，然后不进行write，服务端就会一直卡在read处，此时其他客户端就无法和服务端链接。
 *      即BIO的一大特性，在BIO内部，会进行两次阻塞，一次连接处，一次处理消息处。该特性导致单线程BIO无法处理多客户端请求。
 *  弥补，变成多线程：
 *      当有用户连接上之后，启动一个新的线程去处理read方法，这样主线程就又能回到serverSocket.accept();处进行等待下一个链接。
 *  弥补后的弱点：
 *      多线程下的BIO，每一个请求来了，不管是否发送消息，都会为连接创建一个线程。小了还好，当客户端连接数增多了之后，而且都是不活跃的连接，那么会极大的消耗服务器的资源。
 *
 *  更进一步的解决方案：
 *      将BIO设置成非阻塞的。
 *          -->首先等待连接的地方非阻塞，就会立刻返回消息，然后判断是否拿到了客户端连接，如果没有拿到，就继续循环去获取客户端连接。如果拿到了，就继续往下走
 *          -->然后再将处理消息的地方改成非阻塞的，此时就需要循环去处理消息。将所有的客户端连接放进list里面，然后遍历所有客户端连接，然后读取消息。
 *
 *  好处:
 *      客户端连接可以处理多线程的，所有的客户端都可以链接进来。
 *      不同的客户端，即使是不活跃的客户端也不会浪费多余的线程，不会消耗多余的服务器资源。
 *      从始至终，只有一个线程在处理所有的，精简
 *  不足：
 *      请求数量不多的情况还能接受，如果请求量很大，比如100w，1000w的情况下，处理消息的时候，不管这些客户端有没有发消息，都需要去遍历一遍，这种方式是很不妥当的
 *
 *
 * BIO流程图：  https://kdocs.cn/l/soYqwuH0Q?f=131
 */
package com.geek45.exampleall.io.bio;