/**
 * 为了弥补BIO在多线程下的弱点，所以就引入了NIO
 *
 * NIO主要就是来解决BIO两次阻塞的问题。分别是等待连接时的阻塞和等待数据时的阻塞。
 *
 * 第二个解决的问题：BIO模式下轮训所有连接的问题。
 * 在真实NIO中，并不会在Java层上来进行一个轮询，而是将轮询的这个步骤交给我们的操作系统来进行，他将轮询的那部分代码改为操作系统级别的系统调用（select函数，在linux环境中为epoll），在操作系统级别上调用select函数，主动地去感知有数据的socket。
 *
 *
 *  NIO 服务端详解：
 *
 *      -->监听端口
 *      -->设置为非阻塞
 *      -->将该服务端注册到Selector的连接事件上面。
 *      -->进行死循环，阻塞在事件监听器上面
 *          -->监听到有事件就绪
 *          -->判断是否为连接事件
 *              如果是连接事件，链接到该客户端。
 *              将该客户端注册到读取事件
 *          -->判断是否为读取事件
 *              如果是读取事件，进行读取客户端发来的消息
 *              处理消息
 *              将该客户端注册到写事件
 *          -->判断是否为写事件
 *              如果是写事件，发送数据给客户端
 *              将客户端重新设置为读事件
 *
 *
 *
 */
package com.geek45.exampleall.io.nio;